#!/home/samhaug/anaconda2/bin/python

import numpy as np
import obspy
import seispy
import h5py
from matplotlib import pyplot as plt
from scipy.signal import correlate

'''
Perform a migration to detect reflection coefficients of mid mantle
discontinuities. Must have access to a lookup table, waveform glossary, data
stripped of zeroth-order discontinuities.

See eq (14) of 'A Study of mid-mantle layering beneath the Western Pacific'
1989, Revenaugh & Jordan.
'''

def main():
    wvlt_glossary = h5py.File('/home/samhaug/work1/ScS_reverb_sims/wave_glossary/FJ_20160130.h5','r')
    lkup = h5py.File('/home/samhaug/work1/ScS_reverb_sims/lookup_tables/FJ_20160130.h5','r')

    st = obspy.read('/home/samhaug/work1/ScS_reverb_sims/mineos/FJ_v3.0_h6/FJ_3.0_h6_d28/st_T.pk')
    st.filter('bandpass',freqmin=1/60.,freqmax=1/25.,zerophase=True)
    st.integrate().normalize()
    st = seispy.data.align_on_phase(st,phase=['ScSScS'])
    for idx,tr in enumerate(st):
        st[idx] = seispy.data.phase_window(tr,phase=['ScSScS'],window=(-400,2400))

    #seispy.plot.plot(st[4])

    depth = np.arange(660,664,2)
    idx=4
    stat = st[idx].stats.station
    corr_dict,wave_e = correlate_sig(st[idx],wvlt_glossary)

    R_list = []
    for h in depth:
        h_R = 0
        for keys in corr_dict:
            if 't' in keys:
                continue
            ScS2 = lkup[stat+'/ScS2'][:]
            lkup_t = lkup[stat+'/'+keys][:]
            shift = 55
            h_R += find_R(corr_dict[keys],h,lkup_t,ScS2,shift=shift)/wave_e[keys]
        R_list.append(h_R)

    plt.plot(np.array(R_list),depth)
    plt.ylim(depth.max(),depth.min())
    plt.show()

def correlate_sig(tr,wvlt_glos):
    corr_dict = {}
    wave_e = {}
    for keys in wvlt_glos:
        wvlt = wvlt_glos[keys][...]
        corr_sig = correlate(tr.data,wvlt,mode='same')
        wave_e[keys] = np.dot(wvlt,wvlt)
        corr_dict[keys] = corr_sig
    return corr_dict,wave_e

def find_R(corr_sig,h,lkup,ScS2,**kwargs):
    shift = kwargs.get('shift',0)

    t = lkup[np.argmin(np.abs(lkup[:,0]-h)),1]
    ScS2_time = ScS2[np.argmin(np.abs(lkup[:,0]-h)),1]

    fig,ax = plt.subplots()
    ax.plot(corr_sig,alpha=0.5)
    ax.axvline(t-ScS2_time+400+shift)
    plt.show()

    try:
       r = corr_sig[int(t-ScS2_time+360+shift)]
       return r
    except IndexError:
       return 0
    #corr *= 1./denominator(wvlt_glos)

def denominator(wvlt_glos):
    energy = 0
    for keys in wvlt_glos:
        energy += np.dot(wvlt_glos[keys][...],wvlt_glos[keys][...])
    return energy

main()





