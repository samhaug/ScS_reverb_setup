#!/home/samhaug/anaconda2/bin/python

import obspy
import numpy as np
import seispy
import scipy
from scipy.signal import tukey
from obspy.taup import TauPyModel
from matplotlib import pyplot as plt
from os import listdir
from scipy.signal import correlate

'''
Mask all but zeroth order reverb from synthetic. Subtract from data.
Save higher order reverberations of data
'''

def find_reverb_times(tr,depth,model):
    '''
    Find traveltimes for top and bottomside reverberations at arbitrary depth.
    '''

    evdp = tr.stats.sac['evdp']
    gcarc = tr.stats.sac['gcarc']
    d = str(depth)
    bottomside = ['ScS^'+d+'ScS',
                  'sScS^'+d+'ScS',
                  'ScS^'+d+'ScSScS',
                  'sScS^'+d+'ScSScS',
                  'ScS^'+d+'ScSScSScS',
                  'sScS^'+d+'ScSScSScS']

    topside = ['ScSSv'+d+'SScS',
               'sScSSv'+d+'SScS',
               'ScSSv'+d+'SScSScS',
               'sScSSv'+d+'SScSScS',
               'ScSSv'+d+'SScSScSScS',
               'sScSSv'+d+'SScSScSScS']

    bottomside_arr = model.get_travel_times(source_depth_in_km=evdp,
                                   distance_in_degree=gcarc,
                                   phase_list = bottomside)

    topside_arr = model.get_travel_times(source_depth_in_km=evdp,
                               distance_in_degree=gcarc,
                               phase_list = topside)

    return bottomside,topside,bottomside_arr, topside_arr

def strip_reverb(tr):
    '''
    Use a tukey window to mask an axisem
    trace and only pass the reverberations
    '''
    sr = tr.stats.sampling_rate
    npts = tr.stats.npts
    masked_trace = tr.copy()

    t1 = tukey(185,0.2)
    m1 = np.hstack((np.zeros(30),t1,np.zeros(npts-(30+185))))
    t2 = tukey(175,0.2)
    m2 = np.hstack((np.zeros(945),t2,np.zeros(npts-(945+175))))
    t3 = tukey(160,0.2)
    m3 = np.hstack((np.zeros(1888),t3,np.zeros(npts-(1888+160))))
    masked_trace.data = tr.data*(m1+m2+m3)

    return masked_trace

def synth_setup(syn_dir,st_data):
    print('synth_setup')
    st_syn = obspy.read(syn_dir+'st_T.pk')
    st_syn.filter('bandpass',freqmax=1/25.,freqmin=1/60.)
    st_syn.integrate()
    st_syn = seispy.data.normalize_on_envelope(st_syn,phase=['ScSScS'])
    st_syn = seispy.data.align_on_phase(st_syn,phase=['ScSScS'],a_min=False)
    for idx,tr in enumerate(st_syn):
        st_syn[idx].stats.location = st_syn[idx].stats.sac['gcarc']
        st_syn[idx] = seispy.data.phase_window(tr,['ScSScS'],window=(-50,2050))
        st_syn[idx].stats.starttime = st_data[idx].stats.starttime
        st_syn[idx].data += -1*st_syn[idx].data.mean()
        st_syn[idx].stats.sac['gcarc'] = st_data[idx].stats.sac['gcarc']
    st_syn.interpolate(1)
    st_syn = seispy.data.align_on_phase(st_syn,phase=['ScSScS'],a_min=False)
    st_syn.sort(['location'])
    return st_syn

def data_setup(data_dir):
    print('data_setup')
    st_data = obspy.read(data_dir+'FJ_clean.pk')
    st_data = seispy.data.normalize_on_envelope(st_data,phase=['ScSScS'])
    for idx,tr in enumerate(st_data):
        st_data[idx].stats.location = st_data[idx].stats.sac['gcarc']
        o = tr.stats.sac['o']
        starttime = tr.stats.starttime
        st_data[idx] = seispy.data.phase_window(tr,['ScSScS'],window=(-50,2050))
        st_data[idx].data += -1*st_data[idx].data.mean()
    st_data.interpolate(1)
    st_data = seispy.data.align_on_phase(st_data,phase=['ScSScS'],a_min=False)
    st_data.sort(['location'])
    return st_data

def align_synth_data(trd,trs):
    '''
    Align a synthetic with data based on max correlation.
    '''
    corr = scipy.signal.correlate(trd.data,trs.data,mode='same')
    shift = np.argmax(corr)-int(len(trs.data)/2.)
    trs.data = np.roll(trs.data,shift)
    return trs

data_dir = '/home/samhaug/work1/ScS_reverb_data/20160130/'
syn_dir = '/home/samhaug/work1/ScS_reverb_sims/mineos/FJ_v3.0/FJ_3.0_h6/'
#syn_dir = '/home/samhaug/work1/ScS_reverb_sims/mineos/prem_FJ_okhotsk/'
sts = obspy.read(syn_dir+'st_T.pk')
sts.filter('bandpass',freqmin=1/60.,freqmax=1/25.)
sts.integrate().normalize()
model_10 = TauPyModel(model='prem_3.0_10')

std = obspy.read(data_dir+'FJ_clean.pk')
#std = data_setup(data_dir)
#sts = synth_setup(syn_dir,std)


b,t,ba,ta = find_reverb_times(sts[10],660,model_10)
seispy.plot.plot(sts[10],phase_list=t,model=model_10)
b,t,ba,ta = find_reverb_times(sts[10],410,model_10)
seispy.plot.plot(sts[10],phase_list=t,model=model_10)
#seispy.plot.plot(sts[10],phase_list=['ScS^660ScSScS','sScS^660ScSScS'],model=model_10)
#b,t,ba,ta = find_reverb_times(sts[10],410,model_10)
#seispy.plot.plot(sts[10],phase_list=['ScSScS'],model=model_10)
#for idx, tr in enumerate(sts):
#     mtr = strip_reverb(tr)
#     mtr = align_synth_data(std[idx],mtr)
#     st_mask[idx].data = std[idx].data-mtr.data
#     #plt.plot(std[idx].data-mtr.data)
     #plt.show()
#st_mask.write('mask.pk',format='PICKLE')





